###### TIL - JavaScript

# JavaScript 클로저(Closure)
- 클로저(Closures) 개념 이해
- 실행 컨텍스트(Execution Context)와 렉시컬 스코핑(Lexical Scoping)
- 실용적인 클로저 활용

---

## 클로저(Closures) 개념 이해
- 함수와 함수가 선언된 `어휘적 환경(Lexical Environment)`의 조합
- JavaScript의 매우 강력한 특성으로 `독립적인 변수를 참조하는 함수`. 즉, 클로저에 정의된 함수는 그것이 작성된 환경을 `기억`

### Closure 예제
- `number 변수`는 `updateNumber 함수`를 참조
- (비유) "방 안에서 있는 물건이 방밖에 있는 물건이 넘어갔다. `updateNumber 함수`가 밖으로 나왔다"
- 밖으로 나온 함수가 추후 실행 됐을때(for문에 있는 number함수) 자신이 태어난 공간을 기억! `Lexical Scoping - Closure`

```js
function numberGenerator() {
	// 함수 영역 내 선언된 지역 변수 ==>  실행컨텍스트에 '변수 number'과 'updateNumber함수' => 환경 레코드에 등록  
	var num = 1;
	
	// 함수 영역 내 선언된 지역 함수
	function updateNumber() {
		console.log(num++); // 내부의 함수는 외부의 함수에 접근 가능. 'num'변수는 상위에 찾는다. 스코프 체이닝
	}
	
	// 지역 함수를 반환(return)
	return updateNumber;
}

// numberGenerator() 함수에서 반환된 updateNumber 함수를 변수 number에 참조.
var number = numberGenerator();

// number는 함수 참조로 실행할 때마다 결과가 출력.
for (var i = 0; i < 10; ++i) {
	number();
}

number(); // 1
number(); // 2
number(); // 3
number(); // 4
number(); // 5
number(); // 6
number(); // 7
number(); // 8
number(); // 9
```

- 함수는 실행 될때마다 다시 변수를 정의한다. 즉, 실행 컨텍스트 내부에서 `환경 레코드 영역(메모리)` 에 <변수count>를 재등록되어 초기화가 된다
- count++는 후증가 계속 1만 나온다
```js
function countUp() {
  var count = 1;
  return count++;
}

countUp(); // 1 
countUp(); // 1
countUp(); // 1
```

- count가 업데이트가 될려면  `var count = 1;`를 전역으로 빼야 한다 => `전역 오염`
```js
var count = 1;

function countUp() {  
  return count++;
}

countUp(); // 1 
countUp(); // 2
countUp(); // 3
```
---
## 실행 컨텍스트(Execution Context)와 렉시컬 스코핑(Lexical Scoping)

### 실행 컨텍스트(Execution Contenxt)
- ECMAScript 사양에서 코드의 런타임 평가를 추적하는 데 사용되는 추상개념.
- 어느 시점이든 하나의 실행 컨텍스트만 실행 될 수 있다. 이것이 JavaScript가 `단일 스레드`인 이유
- 즉, 한 번에 하나의 명령만 처리, 브라우저는 `스택(Stack)`을 사용하여 이 실행 컨텍스트를 유지 관리. (스택은 LIFO(Last In First Out) 데이터 구조.)

```js
// 글로벌 실행 컨텍스트 (Global Execution Context)
var x = 9;

// 함수 실행 컨텍스트 (outerFn: Execution Context)
function outerFn() {
  var y = 12;
  
  // 함수 실행 컨텍스트 (innerFn: Execution Context)
  function innerFn() {
    var z = 6;
    return x + y + z;
  }

  return innerFn;
}
```

```js
var x = 10;

function foo(a) {
	// a = 5; // => foo(5)
	var b = 20;

	function bar(c) {
		// c = 15; // moar는 bar함수를 참조		
		var d = 30;
		return boop(x + a + b + c + d); // x:10, a:5, b:20, c:15, d:30 = 80
	}

	function boop(e) {
		// e = 80
		return e * -1; // -80
	}

	return bar;
}

var moar = foo(5); // 클로저(Closure) :
moar(15); // moar는 bar함수를 참조 : -80 출력
```
---
## 실용적인 클로저 활용